---
title: 面试之Java基础
date: 2023-03-01 20:17:16
tags: 面试
categories: Java
---


## 面试之Java基础知识

### 什么是B/S架构？什么是C/S架构？

B/S架构：浏览器/服务器程序

C/S架构：客户端/服务器程序

### Java都有那些开发平台？

JavaSE：主要用在客户端开发

JavaEE：主要用在web应用程序开发

JavaME：主要用在嵌入式应用程序开发

### 什么是JDK？什么是JRE?

JDK：java development kit，java开发工具包，是开发人员所需要安装的环境。

JRE：java runtime environment，java运行环境，java程序运行所需要安装的环境

两者关系：JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。

### Java语言有哪些特点？

- 简单易学，有丰富的类库
- 面向对象
- 与平台无关（JVM）
- 可靠安全
- 支持多线程

### 面向对象和面向过程的区别？

面向对象：站在对象的角度思考问题，把多个功能放在不同的对象里，强调的是具备某些功能的对象，

符合常规的思维方式，稳定性好，使工程更加模块化，实现更低的耦合与更高的内聚；

面向过程：站在过程的角度思考问题，强调的是功能行为，功能的执行过程，即先后顺序，每一个功能可以用函数把这些步骤一步一步实现，使用的时候依次调用函数就可以。

### 什么是数据结构？

计算机保存，组织数据的方式。

### Java的数据结构有那些？

数组，链表，堆，栈，队列，树，图

### 什么是OOP?

面向对象编程

### 类与对象的关系?

类是对象的抽象，对象是类的具体；类是对象的模板，对象是类的实例。

### Java中有几种数据类型？

4类8种

整型：byte，short，int，long

浮点型：float，double

字符型：char

布尔型：boolean

### 标识符的命名规则？

1. 标识符的含义：
   是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识
   符。
2. 命名规则：（硬性要求）
   标识符可以包含英文字母，0-9的数字，$以及_
   标识符不能以数字开头
   标识符不是关键字
3. 命名规范：（非硬性要求）
   类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。
   变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。
   方法名规范：同变量名。

### instanceof关键字的作用？

instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：

```java
boolean result = obj instanceof Class
```

其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或
间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。
注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定
类型，则通过编译，具体看运行时定。

```java
inti=0;
System.out.println(i instanceof Integer);//编译不通过i必须是引用类型，不能是基本类型
System.out.println(i instanceof Object);//编译不通过
Integer integer=newInteger(1);
System.out.println(integer instanceof Integer);//true
//false,在JavaSE规范中对instanceof运算符的规定就是：如果obj为null，那么将返回false。
System.out.println(null instanceof Object);
```



### 什么是隐式转换，什么是显式转换？

显示转换就是类型强转，把一个大类型的数据强制赋值给小类型的数据；隐式转换就是大范围的变量能
够接受小范围的数据；隐式转换和显式转换其实就是自动类型转换和强制类型转换。

### Char类型能不能转成int类型？能不能转化成string类型，能不能转成double类型？

Char在java中也是比较特殊的类型，它的int值从1开始，一共有2的16次方个数据；
Char<int<long<float<double；Char类型可以隐式转成int,double类型，但是**不能隐式转换成string**；如果char类型转成byte，short类型的时候，需要强转。

### 什么是拆装箱？

装箱就是自动将基本数据类型转换为包装器类型（int-->Integer）调用方法：Integer的**valueOf(int)** 方法
拆箱就是自动将包装器类型转换为基本数据类型（Integer-->int）调用方法：Integer的intValue()方法

从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以

```java
Integer i = 10;
```

```java
public class Main {
public static void main(String[] args) {
Integer i1 = 100;
Integer i2 = 100;
Integer i3 = 200;
Integer i4 = 200;
System.out.println(i1==i2);//true
System.out.println(i3==i4);//false
  }
}
```

### Java中的包装类都是那些？

byte：Byte，short：Short，int：Integer，long：Long，float：Float，double：Double，char：
Character ，boolean：Boolean

### 一个java类中包含那些内容？

属性、方法、内部类、构造方法、代码块。

### 那针对浮点型数据运算出现的误差的问题，你怎么解决？

使用Bigdecimal类进行浮点型数据的运算

### 面向对象的特征有哪些方面?

抽象：抽象是将一类对象的共同特征总结出来构造类的过程, 包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为,并不关注这些行为的细节是什么。

继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类(超类、基类) ;得到继承信息的类被称为子类(派生类)。继承让变化中的软件系统有了一定的延续性 ,同时继承也是封装程序中可变因素的重要手段。

封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装；我们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口（可以想想普通洗衣机和全自动洗衣机的差别，明显全自动洗衣机封装更好因此操作起来更简单；我们现在使用的智能手机也是封装得足够好的，因为几个按键就搞定了所有的事情）

多态：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当 A 系统访问 B 系统提供的服务时，B系统有多种提供服务的方式，但一切对 A 系统来说都是透明的（就像电动剃须刀是 A 系统，它的供电系统是 B 系统，B 系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A 系统只会通过 B 类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）。方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。

### 访问修饰符 public,private,protected,以及不写（默认） 时的区别？

| 修饰符    | 当前类 | 同包 | 子类 | 其他包 |
| --------- | ------ | ---- | ---- | ------ |
| public    | 能     | 能   | 能   | 能     |
| protected | 能     | 能   | 能   | 不能   |
| default   | 能     | 能   | 不能 | 不能   |
| private   | 能     | 不能 | 不能 | 不能   |

类的成员不写访问修饰时默认为 default。默认对于同一个包中的其他类相当于公 开（public），对于
不是同一个包中的其他类相当于私有（private）。受保护 （protected）对子类相当于公开，对不是同
一包中的没有父子关系的类相当于私 有。Java 中，外部类的修饰符只能是 public 或默认，类的成员
（包括内部类）的 修饰符可以是以上四种。

### String 是最基本的数据类型吗？

不是。Java 中的基本数据类型只有 8 个：byte、short、int、long、float、double、 char、
boolean；除了基本类型（primitive type），剩下的都是引用类型（reference type），Java 5 以后引
入的枚举类型也算是一种比较特殊的引用类型。

### float f=3.4;是否正确？

不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，
也称为窄化）会造成精度损失，因此需要强制类型转换 float f =(float)3.4; 或者写成 float f=3.4F；实型常量默认情况是作为双精度处理的。

### short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1; 有错吗？

对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int 型，需要强制转换类型才能赋值给 short 型。

而 short s1 = 1; s1 += 1;可以正确编译因为 s1+= 1;相当于 s1 = (short)(s1 +1);其中有隐含的强制类型转换。

### 重载和重写的区别？

重写**(Override)**
从字面上看，重写就是 重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继
承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。

```java
public class Father {
public static void main(String[] args) {
// TODO Auto-generated method stub
Son s = new Son();
s.sayHello();
}
public void sayHello() {
System.out.println("Hello");
}
}
class Son extends Father{
@Override
public void sayHello() {
// TODO Auto-generated method stub
System.out.println("hello by ");
}
}
```

重写 总结：
1.发生在父类与子类之间
2.方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同
3.访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private)
4.重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常

重载**（Overload）**
在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）
则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来
判断重载。

```java
public class Father {
public static void main(String[] args) {
// TODO Auto-generated method stub
Father s = new Father();
s.sayHello();
s.sayHello("wintershii");
}
public void sayHello() {
System.out.println("Hello");
}
public void sayHello(String name) {
System.out.println("Hello" + " " + name);
}
}
```

重载总结：
1.重载Overload是一个类中多态性的一种表现
2.重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)
3.重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准

### equals与==的区别？

**==：**
== 比较的是变量(栈)内存中存放的对象的(堆)内存地址，用来判断两个对象的地址是否相同，即是否是
指相同一个对象。比较的是真正意义上的指针操作。
1、比较的是操作符两端的操作数是否是同一个对象。
2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。
3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：
int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。
**equals：**
equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以
适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的
equals方法返回的却是==的判断。
**总结：**
所有比较是否相等时，都是用equals 并且在对常量相比较时，把常量写在前面，因为使用object的
equals object可能为null 则空指针
在阿里的代码规范中只使用equals ，阿里插件默认会识别，并可以快速修改，推荐安装阿里插件来排
查老代码使用“==”，替换成equals

### ++i与i++的区别？

i++：先赋值，后计算 

++i：先计算，后赋值

### 程序的结构有那些？

顺序结构，选择结构，循环结构

### 数组实例化有几种方式？

静态实例化：创建数组的时候已经指定数组中的元素

```java
int [] a= new int[]{ 1 , 3 , 3}
```

动态实例化：实例化数组的时候，只指定了数组长度，数组中所有元素都是数组类型的默认值

### Java中各种数据默认值？

byte,short,int,long默认是都是0
boolean默认值是false
char类型的默认值是’’
float与double类型的默认是0.0
对象类型的默认值是null

### Java常用包有那些？

Java.lang
Java.io
Java.sql
Java.util
Java.awt
Java.net
Java.math

### Object类常用方法有那些？

clone()

equals()

hashCode()

toString()

notify()

notifyAll()

wait()

getClass()

### java中有没有指针？

有指针，但是隐藏了，开发人员无法直接操作指针，由jvm来操作指针

### java中是值传递引用传递？

理论上说，java都是引用传递，对于基本数据类型，传递是值的副本，而不是值本身。对于对象类型，
传递是对象的引用，当在一个方法操作操作参数的时候，其实操作的是引用所指向的对象。

### 实例化数组后，能不能改变数组长度呢？

不能，数组一旦实例化，它的长度就是固定的

### 假设数组内有5个元素，如果对数组进行反序，该如何做？

逆向遍历数组，存入新数组

### 形参与实参区别？

**实参(argument)：**
全称为"实际参数"是在调用时传递给函数的参数. 实参可以是常量、变量、表达式、函数等， 无论实参
是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应
预先用赋值，输入等办法使实参获得确定值。
**形参(parameter)：**
全称为"形式参数" 由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用
的参数,目的是用来接收调用该函数时传入的参数.在调用函数时，实参将赋值给形参。因而，必须注意
实参的个数，类型应与形参一一对应，并且实参必须要有确定的值。
形参出现在**函数定义**中，在整个函数体内都可以使用， 离开该函数则不能使用。
实参出现在**主调函数中，进入被调函数后，实参变量也不能使用。**
形参和实参的功能是作数据传送。发生函数调用时， 主调函数把实参的值传送给被调函数的形参从而实
现主调函数向被调函数的数据传送。
1.形参变量只有在被调用时才分配内存单元，**在调用结束时， 即刻释放所分配的内存单元**。因此，形参
只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。
2.实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必
须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。
3.实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。
4.**函数调用中发生的数据传送是单向的**。 即只能把实参的值传送给形参，而不能把形参的值反向地传送
给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。
5.当形参和实参不是指针类型时，在该函数运行时，**形参和实参是不同的变量，他们在内存中位于不同**
**的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。**
**而如果函数的参数是指针类型变量,在调用该函数的过程中，传给函数的是实参的地址，在函数体内部使**
**用的也是实参的地址，即使用的就是实参本身**。所以在函数体内部可以改变实参的值。

### 构造方法能不能显式调用？

不能，构造方法当成普通方法调用，只有在创建对象的时候它才会被系统调用

### 构造方法能不能重写？能不能重载？

能重载，不能重写

### 内部类与静态内部类的区别？

静态内部类相对与外部类是独立存在的，在静态内部类中无法直接访问外部类中变量、方法。如果要访
问的话，必须要new一个外部类的对象，使用new出来的对象来访问。但是可以直接访问静态的变量、
调用静态的方法；
普通内部类作为外部类一个成员而存在，在普通内部类中可以直接访问外部类属性，调用外部类的方
法。
如果外部类要访问内部类的属性或者调用内部类的方法，必须要创建一个内部类的对象，使用该对象访
问属性或者调用方法。
如果其他的类要访问普通内部类的属性或者调用普通内部类的方法，必须要在外部类中创建一个普通内
部类的对象作为一个属性，外同类可以通过该属性调用普通内部类的方法或者访问普通内部类的属性如果其他的类要访问静态内部类的属性或者调用静态内部类的方法，直接创建一个静态内部类对象即可。

### Static关键字有什么作用？

Static可以修饰内部类、方法、变量、代码块
Static修饰的类是**静态内部类**
Static修饰的方法是**静态方法**，表示该方法属于当前类的，而不属于某个对象的，静态方法也不能被重
写，可以直接使用类名来调用。在static方法中不能使用this或者super关键字。
Static修饰变量是**静态变量或者叫类变量**，静态变量被所有实例所共享，不会依赖于对象。静态变量在
内存中只有一份拷贝，在JVM加载类的时候，只为静态分配一次内存。
Static修饰的代码块叫**静态代码块**，通常用来做程序优化的。静态代码块中的代码在整个类加载的时候
只会执行一次。静态代码块可以有多个，如果有多个，按照先后顺序依次执行。

### final在java中的作用，有哪些用法?

1. final修饰的类不可以被继承
2. final修饰的方法不可以被重写
3. final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.
4. final修饰的方法,JVM会尝试将其内联,以提高运行效率
5. final修饰的常量,在编译阶段会存入常量池中

除此之外,编译器对final域要遵守的两个重排序规则更好:
在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序
初次读一个包含fifinal域的对象的引用,与随后初次读这个fifinal域,这两个操作之间不能重排序

### String ，StringBuffffer 和 StringBuilder 的区别是什么？

**String**是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个final类型的字
符数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对String的操作都会生成新的
String对象

```java
private final char value[];
```

**StringBuffer**是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个**线程安全**的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。

**StringBuilder**是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，减小了开销，是绝大部分情况下进行字符串拼接的首选。

**StringBuilder和StringBuffer的内部实现跟String类一样，都是通过一个char数组存储字符串的，不同的是String类里面的char数组是final修饰的，是不可变的，而StringBuilder和StringBuffer的char数组是可变的。所以在进行频繁的字符串操作时，建议使用StringBuffer和 StringBuilder来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。**

### 讲下java中的math类有那些常用方法？

Pow()：幂运算 Sqrt()：平方根 Round()：四舍五入 Abs()：求绝对值 Random()：生成一个0-1的随机
数，包括0不包括1

### String类的常用方法有那些？

charAt：返回指定索引处的字符 indexOf()：返回指定字符的索引 replace()：字符串替换 trim()：去除
字符串两端空白 split()：分割字符串，返回一个分割后的字符串数组 getBytes()：返回字符串的byte类
型数组 length()：返回字符串长度 toLowerCase()：将字符串转成小写字母 toUpperCase()：将字符串
转成大写字符 substring()：截取字符串 format()：格式化字符串 equals()：字符串比较

### Java中的继承是单继承还是多继承？

Java中既有单继承，又有多继承。对于java类来说只能有一个父类，对于接口来说可以同时继承多个接
口

### Super与this表示什么？

Super表示当前类的父类对象； This表示当前类的对象

### 普通类与抽象类有什么区别？

普通类不能包含抽象方法，抽象类可以包含抽象方法 抽象类不能直接实例化，普通类可以直接实例化

### 什么是接口？为什么需要接口？

接口就是某个事物对外提供的一些功能的声明，是一种特殊的java类，接口弥补了java类单继承的缺点

### 接口有什么特点？

接口中声明全是public static final修饰的常量 

接口中所有方法都是抽象方法 接口是没有构造方法的 

接口也不能直接实例化 接口可以多继承

### 抽象类和接口的区别?

抽象类：

1. 抽象方法，只有行为的概念，没有具体的行为实现。使用abstract关键字修饰，没有方法体。子类
   必须重写这些抽象方法。
2. 包含抽象方法的类，一定是抽象类。
3. 抽象类只能被继承，一个类只能继承一个抽象类。

接口：

1. 全部的方法都是抽象方法，属性都是常量
2. 不能实例化，可以定义变量。
3. 接口变量可以引用具体实现类的实例
4. 接口只能被实现，一个具体类实现接口，必须实现全部的抽象方法
5. 接口之间可以多实现
6. 一个具体类可以实现多个接口，实现多继承现象

### Hashcode的作用？

java的集合有两类，一类是List，还有一类是Set。前者有序可重复，后者无序不重复。当我们在set中
插入的时候怎么判断是否已经存在该元素呢，可以通过equals方法。但是如果元素太多，用这样的方法
就会比较满。
于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域，每个对
象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就
可以确定该对象应该存储的那个区域。
hashCode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合
要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。
如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上
已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地
址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。

### Java的四种引用，强弱软虚？

**强引用**
强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方式：

```java
String str = new String("str");
```

**软引用**
软引用在程序内存不足时，会被回收，使用方式：

```java
// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，
// 这里的软引用指的是指向new String("str")的引用，也就是SoftReference类中T
SoftReference<String> wrf = new SoftReference<String>(new String("str"));
```

可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。

**弱引用**
弱引用就是只要JVM垃圾回收器发现了它，就会将之回收，使用方式：

```java
WeakReference<String>wrf=newWeakReference<String>(str);
```

可用场景：Java源码中的java.util.WeakHashMap中的key就是使用弱引用，我的理解就是，
一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。

**虚引用**
虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入ReferenceQueue中。注意哦，其它
引用是被JVM回收后才被传入ReferenceQueue中的。由于这个机制，所以虚引用大多被用于引用销毁
前的处理工作。还有就是，虚引用创建的时候，必须带有ReferenceQueue使用

```java
PhantomReference<String>prf=newPhantomReference<String>(new
String("str"),newReferenceQueue<>());
```

可用场景： 对象销毁前的一些操作，比如说资源释放等。Object.finalize() 虽然也可以做这类动作，
但是这个方式即不安全又低效。上诉所说的几类引用，都是指对象本身的引用，而不是指 Reference 的四个子类的引用( SoftReference 等)。

### Java创建对象有几种方式？

java中提供了以下四种创建对象的方式:

1. new创建新对象
2. 通过反射机制
3. 采用clone机制
4. 通过序列化机制

### 有没有可能两个不相等的对象有相同的hashcode？

有可能.在产生hash冲突时,两个不相等的对象就会有相同的 hashcode 值.当hash冲突产生时,一般有以
下几种方式来处理:

1. 拉链法:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被
   分配到同一个索引上的多个节点可以用这个单向链表进行存储.
2. 开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找
   到,并将记录存入
3. 再哈希:又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算
   地址,直到无冲突.

### 拷贝和浅拷贝的区别是什么?

**浅拷贝:**
被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指向原来的对象.
换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.
**深拷贝:**
被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对
象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的对象都复制了一遍.

### a=a+b与a+=b有什么区别吗?

+= 操作符会进行隐式自动类型转换,此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类型,
而a=a+b则不会自动进行类型转换。

### final、finalize()、finally？

**性质不同**

1. final为关键字；
2. finalize()为方法；
3. finally为区块标志，用于try语句中

**作用**

1. final为用于标识常量的关键字，final标识的关键字存储在常量池中；
2. finalize()方法在Object中进行了定义，用于在对象“消失”时，由JVM进行调用用于对对象进行垃圾
   回收，类似于C++中的析构函数；用户自定义时，用于释放对象占用的资源（比如进行I/0操作）；
3. finally{}用于标识代码块，与try{}进行配合，不论try中的代码执行完或没有执行完（这里指有异
   常），该代码块之中的程序必定会进行；

### JDBC操作的步骤？

1. 加载数据库驱动类 
2. 打开数据库连接 
3. 执行sql语句 
4. 处理返回结果 
5. 关闭资源

### 在使用jdbc的时候，如何防止出现sql注入的问题？

使用PreparedStatement类，而不是使用Statement类

### 怎么在JDBC内调用一个存储过程？

使用CallableStatement

### 是否了解连接池，使用连接池有什么好处？

数据库连接是非常消耗资源的，影响到程序的性能指标。连接池是用来分配、管理、释放数据库连接
的，可以使应用程序重复使用同一个数据库连接，而不是每次都创建一个新的数据库连接。通过释放空
闲时间较长的数据库连接避免数据库因为创建太多的连接而造成的连接遗漏问题，提高了程序性能。

### 你所了解的数据源技术有那些？使用数据源有什么好处？

Dbcp,c3p0等，用的最多还是c3p0，因为c3p0比dbcp更加稳定，安全；通过配置文件的形式来维护数
据库信息，而不是通过硬编码。当连接的数据库信息发生改变时，不需要再更改程序代码就实现了数据
库信息的更新

### &和&&的区别？

&是位运算符。&&是布尔逻辑运算符，在进行逻辑判断时用&处理的前面为false后面的内容仍需处理，
用&&处理的前面为false不再处理后面的内容。

### 静态内部类如何定义？

定义在类内部的静态类，就是静态内部类。

```java
public class Out {
private static int a;
private int b;
public static class Inner {
public void print() {
System.out.println(a);
    }
   }
}
```

1. 静态内部类可以访问外部类所有的静态变量和方法，即使是 private 的也一样。
2. 静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。
3. 其它类使用静态内部类需要使用“外部类.静态内部类”方式，如下所示：Out.Inner inner = new
   Out.Inner();inner.print();
4. Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象，
   HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部类关
   系密切的，且不依赖外部类实例的，都可以使用静态内部类。

### 什么是成员内部类？

定义在类内部的非静态类，就是成员内部类。成员内部类不能定义静态方法和变量（final修饰的除
外）。这是因为成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内部类定义
静态变量，那么成员内部类的静态变量初始化顺序是有歧义的

```java
public class Out {
private static int a;
private int b;
public class Inner {
public void print() {
System.out.println(a);
System.out.println(b);
     }
}
```

### 什么时候用assert？

assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。在实现中，
assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个
boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，系统将给出警告或
退出。一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时
开启。为了提高性能，在软件发布后，assertion检查通常是关闭的。

### Java有没有goto？

java中的保留字，现在没有在java中使用

### 数组有没有length()这个方法? String有没有length()这个方法？

数组没有length()这个方法，有length的属性。String有有length()这个方法

### 用最有效率的方法算出2乘以8等于几？

2 << 3

### 排序都有哪几种方法？请列举

排序的方法有：插入排序（直接插入排序、希尔排序），交换排序（冒泡排序、快速排序），选择排序
（直接选择排序、堆排序），归并排序，分配排序（箱排序、基数排序）

### 静态变量和实例变量的区别？

static i = 10; //常量 class A a; a.i =10;//可变

### 说出一些常用的类，包，接口，请各举5个

常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer常用的包：java.lang
java.awt java.io java.util java.sql常用的接口：Remote List Map Document NodeList

### a.hashCode() 有什么用？与 a.equals(b) 有什么关系？

hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap 等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用
equal() 方法来判断相等的对象，必须具有相同的 hash code。

### 两个对象值相同(x.equals(y) == true)，但却可有不同的hashcode，这句话对不对？

不对，如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码（hash code）应当相同。Java 对
于 eqauls 方法和 hashCode 方法是这样规定的：
(1)如果两个 对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；
(2)如果两个对象的 hashCode 相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你
违背了上述原则就会发现在使用容器时，相同的对象可以出现在 Set 集合中，同时增加新元素的效率会
大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。

### 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？

是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中
时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不
会影响到调用者的。

### char 型变量中能不能存贮一个中文汉字，为什么？

char 类型可以存储一个中文汉字，因为 Java 中使用的编码是 Unicode（不选择任何特定的编码，直接
使用字符在字符集中的编号，这是统一的唯一方法），一个 char 类型占 2 个字节（16 比特），所以放
一个中文是没问题的。

**补充**：使用 Unicode 意味着字符在 JVM 内部和外部有不同的表现形式，在 JVM内部都是 Unicode，当
这个字符被从 JVM 内部转移到外部时（例如存入文件系统中），需要进行编码转换。

所以 Java 中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如InputStreamReader 和OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务

### 如何实现对象克隆？

实现 Cloneable 接口并重写 Object 类中的 clone()方法；

实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真 正的深度克隆
